You are a meticulous senior Node/TypeScript engineer. Extend the existing Auth Service (Fastify + better-auth) so it supports and can be QA-tested for: JWT, Bearer, API Key, Admin, and Organization (multi-tenant). Keep production endpoints clean; expose **DEV-ONLY** QA endpoints guarded by an env flag.

REPO: https://github.com/Rndynt/AuthCore
BASE_NETLIFY=https://transity-auth.netlify.app
BASE_REPLIT=https://c25f0f2e-887e-4494-845b-803084ff23ee-00-2rxeabtep8sj0.janeway.replit.dev

GOALS
- End-user email/password already works (session cookies). Add QA endpoints to verify:
  1) API Key S2S (x-api-key)
  2) JWT mint + JWKS (Bearer for polyglot services)
  3) Admin tooling (list users, optional impersonation)
  4) Organization lifecycle (create org, add member, set role, list members)
- QA endpoints must respond to cookie session OR x-api-key OR Authorization: Bearer.
- QA endpoints are available ONLY when ENABLE_DEV_ENDPOINTS=true; otherwise return 404.

ENV CHANGES
- Add to .env.example and set in Replit + Netlify:
  ENABLE_DEV_ENDPOINTS=false
- Ensure existing env still present: DATABASE_URL (with sslmode=require if serverless), BETTER_AUTH_URL, BETTER_AUTH_SECRET, TRUSTED_ORIGINS.

IMPLEMENTATION (add under Fastify app)
- In src/env.ts export: export const devEnabled = process.env.ENABLE_DEV_ENDPOINTS === 'true';
- In src/server.ts after existing routes, mount a prefix “/dev” only if devEnabled is true; otherwise register a 404 handler for /dev/*.
- For each request, reconstruct Headers from Fastify req.headers and call: const session = await auth.api.getSession({ headers });
- Build small helpers:
  - requireUser(): 401 if no session user.
  - requireAdmin(): 403 if current user not admin (use admin plugin checks).
  - requireOrgRole(orgId, roles[]): 403 unless user has one of roles in that org (via organization plugin).
  - authMode used = “cookie” | “apiKey” | “bearer” (detect from headers) and include in /dev/whoami response.

DEV QA ENDPOINTS (mount only when devEnabled)
1) GET /dev/whoami
   Returns { mode, user: {id,email}, memberships: [{orgId, role}], permissions?: [...] } resolved from session/apiKey/bearer.

2) API Key
   - POST /dev/api-keys
     Body: { userId?: string, label?: string, expiresInDays?: number }
     Creates API key for given userId, or for current user if omitted. Only admin or self.
     Return: { key, keyId, userId, label, expiresAt }
   - GET /dev/api-keys?userId=...
     List user’s API keys (admin or owner).
   - DELETE /dev/api-keys/:keyId
     Revoke key (admin or owner).

3) JWT / Bearer
   - POST /dev/jwt/issue
     Body: { userId?: string, audience?: string, ttlSeconds?: number, scopes?: string[] }
     Issues short-lived JWT for given user or current user. Return: { token, expiresAt }
   - GET /dev/jwks.json
     Serve JWKS from jwt plugin (either proxy its path or expose directly).

4) Organization (multi-tenant)
   - POST /dev/orgs
     Body: { name: string } → create org. Return { org }
   - POST /dev/orgs/:orgId/members
     Body: { email: string, role: "owner"|"admin"|"member" }
     Add member by email (create user if not exists as placeholder). Require org owner/admin.
   - PATCH /dev/orgs/:orgId/members/:userId
     Body: { role: "owner"|"admin"|"member" } → set role. Require owner/admin.
   - GET /dev/orgs/:orgId/members
     List members {userId,email,role}. Require owner/admin.

5) Admin
   - GET /dev/admin/users?limit=50&cursor=... → list users (admin only).
   - OPTIONAL POST /dev/admin/impersonate
     Body: { userId: string, as: "cookie"|"jwt" }
     For QA only: sets a dev cookie or returns a dev JWT for that user. Very clearly DEV-ONLY.

NOTES
- Reuse existing “auth” (betterAuth instance). Use the official plugin APIs:
  - API Key plugin: create/list/revoke keys; session is mocked when x-api-key is supplied.
  - JWT plugin: issue tokens; expose JWKS.
  - Organization plugin: create org, manage memberships/roles.
  - Admin plugin: list users, optional impersonation.
- Responses must be concise JSON; never log secrets or full tokens.
- CORS remains credentials: true; origin filtered by trustedOrigins.

README UPDATE (append)
- “DEV QA Endpoints” section:
  - Enable with ENABLE_DEV_ENDPOINTS=true (Replit + Netlify).
  - Warn: Do NOT enable in production.
  - Document curl samples (below) and how to consume from other microservices:
    - API Key → header: x-api-key
    - Bearer → Authorization: Bearer <JWT>, verify with JWKS URL

SMOKE SCRIPTS (add to package.json)
- smoke:dev:whoami:netlify
- smoke:dev:whoami:replit
- smoke:dev:apikey:create:netlify
- smoke:dev:jwt:issue:netlify
- smoke:dev:org:create:netlify
Each runs the matching curl below (exit non-zero on non-2xx).

CURL EXAMPLES (replace BASE with either ${BASE_NETLIFY} or ${BASE_REPLIT})
- WHOAMI (cookie)
  curl -i -c cookie.txt -b cookie.txt BASE/dev/whoami
- WHOAMI (api key)
  curl -i -H "x-api-key: REPLACE_KEY" BASE/dev/whoami
- WHOAMI (bearer)
  curl -i -H "Authorization: Bearer REPLACE_JWT" BASE/dev/whoami
- CREATE API KEY (self/admin)
  curl -i -c cookie.txt -b cookie.txt -X POST BASE/dev/api-keys -H "Content-Type: application/json" --data '{"label":"orders-svc","expiresInDays":90}'
- ISSUE JWT (for current user)
  curl -i -c cookie.txt -b cookie.txt -X POST BASE/dev/jwt/issue -H "Content-Type: application/json" --data '{"ttlSeconds":1800,"audience":"orders-api","scopes":["orders:read"]}'
- JWKS
  curl -s BASE/dev/jwks.json
- ORG create
  curl -i -c cookie.txt -b cookie.txt -X POST BASE/dev/orgs -H "Content-Type: application/json" --data '{"name":"Acme Corp"}'
- ORG add member
  curl -i -c cookie.txt -b cookie.txt -X POST BASE/dev/orgs/REPLACE_ORG_ID/members -H "Content-Type: application/json" --data '{"email":"member@example.com","role":"admin"}'
- ORG set role
  curl -i -c cookie.txt -b cookie.txt -X PATCH BASE/dev/orgs/REPLACE_ORG_ID/members/REPLACE_USER_ID -H "Content-Type: application/json" --data '{"role":"owner"}'
- ORG list members
  curl -i BASE/dev/orgs/REPLACE_ORG_ID/members

ACCEPTANCE CRITERIA
- ENABLE_DEV_ENDPOINTS=false → all /dev/* return 404.
- ENABLE_DEV_ENDPOINTS=true → all QA endpoints work on Replit and Netlify:
  • /dev/whoami returns identity + memberships via cookie, api key, or bearer.
  • API Key create/list/revoke works; a call with x-api-key hits /dev/whoami successfully.
  • JWT issue returns a token; JWKS available; token verifies against JWKS.
  • Org lifecycle works (create org → add member → set role → list members) with proper role checks.
  • Admin users list requires admin.
- README updated with the new section and curl examples.
- Print a final report: endpoints matrix, diffs, commands executed, and transcripts of the smoke calls (status + brief JSON).
